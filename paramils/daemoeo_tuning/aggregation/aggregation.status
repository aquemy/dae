
######                 General    ######
--help=0                                 # -h : Prints this message
--stopOnUnknownParam=1                   # Stop if unkown param entered

### EVALUATION #####################################################################
--bmax-init=1000000                        # -B : Number of allowed expanded nodes for the initial computation of b_max
--fitness-weight=15                      # -W : Unknown weight in the feasible and unfeasible fitness computation
--fitness-penalty=1000                  # -w : Penalty in the unfeasible fitnesses computation
--bmax-fixed=1000000                               # -b : Fixed number of allowed expanded nodes. Overrides bmaxinit if != 0
--bmax-last-weight=1                     # -T : Weighting for the b_max used during the last search towards             # -T : Weighting for the b_max used during the last search towards the end goal (must be strictly positive)
--bmax-quantile=0.5                      # -Q : Quantile to use for estimating b_max (in [0,1], 0.5=median)
 --lenght_weigth=1                        # -H : Weighting for the optimizing lenght during the search
 --cost_weigth=1                          # -U : Weighting for the optimizing cost during the search
 --makespan_max_weigth=1                  # -Y : Weighting for the optimizing makespan_max during the search
 --makespan_add_weigth=1                  # -V : Weighting for the optimizing  makespan_add during the search
 --astar_weigth=10                         # -O : Weighting for the optimizing  A* heuristic during the search
 --rand_yahsp_seed=1                      # -X : flag  for the random initilaization of yahsp at each optimization
 --alpha=0.5                              # -x : Aggregation param for the fitness func. (alp.* makespan + (1-alp.) (cost/risk))
 --bmax-increase-coef=1                   # -K : Multiplier increment for the computation of b_max
 --bmax-ratio=0.01                        # -J : Satisfying proportion of feasible individuals for the computation of b_max

######    Evolution Engine        ######
--popSize=300                       # -P : Population Size
--updateArch=1                      # Update the archive at each gen.
--selection=DetTour(2)	            #Selection: DetTour(T), StochTour(t), Roulette, Ranking(p,e) or Sequential(ordered/unordered) (optional, default: DetTour(2))
--nbOffspring=100%	                #Nb of offspring (percentage or absolute) (optional, default: 100% )
--replacement=Comma	                #Replacement: Comma, Plus or EPTour(T), SSGAWorst, SSGADet(T), SSGAStoch(t) (optional, default: Comma)
--weakElitism=0                 	#Old best parent replaces new worst offspring *if necessary* (optional, default: 0)

######    Initialization          ######
--lmax-initcoef=3                        # -N : l_max will be set to the size of the chrono partition * this coefficient
--lmin=1                                 # -M : Minimum number of goals in a decomposition

######    Logger                  ######
--verbose=quiet                          # -v : Set the verbose level
--print-verbose-levels=0                 # -l : Print verbose levels
--output=                                # -o : Redirect a standard output to a file

######    Output                  ######
--plan-file=plan.soln                    # -f : Plan file backup
--resDir=agg                             # Directory to store DISK outputs
--eraseDir=1                             # erase files in dirName if any
--printPop=0                             # Print sorted pop. every gen.
--printPlan=0                            # Print sorted plan. every gen.
--storeArch=0                            # Store the archive's objective vectors at each gen.
--printArch=0                            # Print the archive at each gen.
--saveIntervalArch=60                    # Save the archive's objective vectors every T seconds (0 or absent = never)
--printIntervalArch=0                   # Print the archive at each time interval
--storePopVectors=0                      # Store the pop's objective vectors at each gen.
--printPopVectors=0                      # Print the pop vectors at each gen.
--saveIntervalPopVectors=10
--contribution=0                         # Store the contribution of the archive at each gen.
--entropy=0                              # Store the entropy of the archive at each gen.
--hypervolume=0                          # Store the hypervolume of the archive at each gen.
--EpsilonAdditive=0                      # Store the Epsilon Additive of the archive at each gen.
--printStats=0                           # Print Best/avg/feasible every gen.
--printBestStat=0                        # Print Best/avg// every gen.

######    Persistence             ######
--saveFrequency=0                        # Save every F generation (0 = only final state, absent = never)
--saveTimeInterval=0                     # Save every T seconds (0 or absent = never)

######    Problem                 ######
--domain=./domain.pddl   # -D : PDDL domain file REQUIRED 
--sequential=0                           # -q : Is the problem a sequential one? REQUIRED 
--objective=Add                          # -Z : 2nd objective to take into account (Add(additive cost )/Max(max cost)

######    Stopping criterion      ######
--maxGen=0                               # -G : Maximum number of generations
--steadyGen=100000                          # -s : Number of generations with no improvement
# --minGen=0                               # -g : Minimum number of generations
# --maxEval=0                              # -E : Maximum number of evaluations (0 = none)
--maxTime=310                            # -T : Maximum running time in seconds (0 = none)
#--CtrlC=0                                # -C : Terminate current generation upon Ctrl C                           # -C : Terminate current generation upon Ctrl C

### VARIATION ######################################################################
--radius=2                               # -R : Number of neighbour goals to consider for the addGoal mutation
--proba-change=0.8                       # -k : Probability to change an atom for the changeAtom mutation
--proba-del-atom=0.5                     # -p : Average probability to delete an atom for the delAtom mutation
--w-delgoal=1                            # -a : Relative weight defining the probability to call the delGoal mutation
--w-addgoal=1                            # -A : Relative weight defining the probability to call the addGoal mutation
--w-delatom=3                            # -u : Relative weight defining the probability to call the delAtom mutation
--w-addatom=1                            # -d : Relative weight defining the probability to call the addAtom mutation
--maxtry-candidate=0                     # -y : Maximum number of atoms to try when searching for a candidate in the changeAtom mutation
--maxtry-mutex=0                         # -z : Maximum number of atoms to try when searching for mutexes in the changeAtom mutation
--proba-cross=0.2                        # -c : Probability to apply a cross-over
--proba-mut=0.8                          # -m : Probability to apply one of the mutation
